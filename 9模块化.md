# 模块化
## commonjs

### nodejs的安装
https://nodejs.org/zh-cn/

安装后 可以使得js文件直接在node环境运行
方式：  1.在命令行 进入js文件绝对位置 再输入  node js文件名
        2.在vscode内右键js文件 选择在终端中打开 再输入 node js文件名  快捷键 ctrl+j


在node内可以使用任何ecmascript标准的语法或api 但是不能使用web api 因为脱离了浏览器环境

- 模块化
模块的核心要素 ：隐藏和暴露   隐藏自己的内部实现，暴露外部的接口使用  暴露的过程即为模块的导出
    当需要使用一个模块时，使用的是该模块暴露的部分（导出的部分），隐藏的部分是永远无法使用的。
    当通过某种语法或api去使用一个模块时，这个过程叫做模块的导入
### commonjs
CommonJS使用exports导出模块，require导入模块
    具体规范如下：
            如果一个JS文件中存在exports或require，该JS文件是一个模块
            模块内的所有代码均为隐藏代码，包括全局变量、全局函数，这些全局的内容均不应该对全局变量造成任何污染
            如果一个模块需要暴露一些API提供给外部使用，需要通过exports导出，exports是一个空的对象，你可以为该对象添加任何需要导出的内容
            如果一个模块需要导入其他模块，通过require实现，require是一个函数，传入模块的路径即可返回该模块导出的整个内容
其实他是把所有的代码都放在了一个函数内执行  (function(){
                                            //模块中的代码
                                                })()
然后利用exports导出：其实内部是初始化了一个值 module.exports={} 即为模块的导出值 为了方便开发，在初始化该值后 又声明了一个变量exports=module.exports
             (function(module){
                     module.exports = {};
                    var exports = module.exports;
                    //模块中的代码
                    return module.exports;
                    })()


            所以最终导出还是 module.exports的值  所以使用exports 和 module.exports是一样的 但是module.exports更好 注意二者不可共存 

## 浏览器模块化的难题 浏览器不能使用commonjs的原因
CommonJS的工作原理
当使用require(模块路径)导入一个模块时，node会做以下两件事情（不考虑模块缓存）：

通过模块路径找到本机文件，并读取文件内容
将文件中的代码放入到一个函数环境中执行，并将执行后module.exports的值作为require函数的返回结果
正是这两个步骤，使得CommonJS在node端可以良好的被支持

可以认为，CommonJS是同步的，必须要等到加载完文件并执行完代码后才能继续向后执行

当浏览器遇到CommonJS

当想要把CommonJS放到浏览器端时，就遇到了一些挑战

浏览器要加载JS文件，需要远程从服务器读取，而网络传输的效率远远低于node环境中读取本地文件的效率。由于CommonJS是同步的，这会极大的降低运行性能
如果需要读取JS文件内容并把它放入到一个环境中执行，需要浏览器厂商的支持，可是浏览器厂商不愿意提供支持，最大的原因是CommonJS属于社区标准，并非官方标准

基于以上两点原因，浏览器无法支持模块化

可这并不代表模块化不能在浏览器中实现

要在浏览器中实现模块化，只要能解决上面的两个问题就行了

解决办法其实很简单：

远程加载JS浪费了时间？做成异步即可，加载完成后调用一个回调就行了
模块中的代码需要放置到函数中执行？编写模块时，直接放函数中就行了
基于这种简单有效的思路，出现了AMD和CMD规范，有效的解决了浏览器模块化的问题

### AMD
全称是Asynchronous Module Definition，即异步模块加载机制

require.js实现了AMD规范

在AMD中，导入和导出模块的代码，都必须放置在define函数中

define([依赖的模块列表], function(模块名称列表){
    //模块内部的代码
    return 导出的内容
})

### CMD
全称是Common Module Definition，公共模块定义规范

sea.js实现了CMD规范

在CMD中，导入和导出模块的代码，都必须放置在define函数中

define(function(require, exports, module){
    //模块内部的代码
})

## es6模块化开发
ECMA组织参考了众多社区模块化标准，终于在2015年，随着ES6发布了官方的模块化标准，后成为ES6模块化

    ES6模块化具有以下的特点
        使用依赖预声明的方式导入模块
            依赖延迟声明
                优点：某些时候可以提高效率
                缺点：无法在一开始确定模块依赖关系（比较模糊）
            依赖预声明
                优点：在一开始可以确定模块依赖关系
                缺点：某些时候效率较低
        灵活的多种导入导出方式
        规范的路径表示法：所有路径必须以./或../开头

### 基本导入导出

模块的引入  注意：这一部分非模块化标准   目前，浏览器使用以下方式引入一个ES6模块文件
    <script src="入口文件" type="module">

ES6中的模块导入导出分为两种：
                    基本导入导出
                    默认导入导出


- 基本导出
     类似于 exports.xxx = xxxx

    基本导出可以有多个，每个必须有名称
        基本导出的语法如下：
                        export 声明表达式   或  export {具名符号}
                            由于基本导出必须具有名称，所以要求导出内容必须跟上声明表达式或具名符号

- 基本导入
            由于使用的是依赖预加载，因此，导入任何其他模块，导入代码必须放置到所有代码之前

        对于基本导出，如果要进行导入，使用下面的代码

                        import {导入的符号列表} from "模块路径" 
    注意以下细节：
        导入时，可以通过关键字as对导入的符号进行重命名
        导入时使用的符号是常量，不可修改
        可以使用*号导入所有的基本导出，形成一个对象



- 默认导出
        每个模块，除了允许有多个基本导出之外，还允许有一个默认导出
        默认导出类似于CommonJS中的module.exports，由于只有一个，因此无需具名

    具体的语法是   export default 默认导出的数据  或  export {默认导出的数据 as default}
        由于每个模块仅允许有一个默认导出，因此，每个模块不能出现多个默认导出语句

- 默认导入
        需要想要导入一个模块的默认导出，需要使用下面的语法

    import 接收变量名 from "模块路径"
    类似于CommonJS中的

    var 接收变量名 = require("模块路径")
        由于默认导入时变量名是自行定义的，因此没有别名一说

        如果希望同时导入某个模块的默认导出和基本导出，可以使用下面的语法

        import 接收默认导出的变量, {接收基本导出的变量} from "模块路径"
        注：如果使用*号，会将所有基本导出和默认导出聚合到一个对象中，默认导出会作为属性default存在

### 细节 
- 尽量导出不可变值
当导出一个内容时，尽量保证该内容是不可变的（大部分情况都是如此）

因为，虽然导入后，无法更改导入内容，但是在导入的模块内部却有可能发生更改，这将导致一些无法预料的事情发生

- 可以使用无绑定的导入用于执行一些初始化代码
如果我们只是想执行模块中的一些代码，而不需要导入它的任何内容，可以使用无绑定的导入：
import "模块路径"

- 可以使用绑定再导出，来重新导出来自另一个模块的内容
有的时候，我们可能需要用一个模块封装多个模块，然后有选择的将多个模块的内容分别导出，可以使用下面的语法轻松完成
export {绑定的标识符} from "模块路径"
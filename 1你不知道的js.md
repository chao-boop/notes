# js的执行机制

# bind的使用

底层是用到了call和apply的方法  所以原理和他们一样
比如 a.bind(b,q,w)  第一个参数 使a对象内的this指向b  后面的参数都作为a的参数传递给a对象  ，就是改变了a内的this指向为b对象

# 纯函数
函数在执行功能的时候不依赖于外界的变量 也不会影响到外界变量 

作用：纯函数非常容易进行单元测试，因为不需要考虑上下文环境，只需要考虑输入和输出
# 柯里化
一种将使用多个参数的一个函数转化成一系列使用一个参数的函数的技术

主要用途就是简化代码结构，提高系统的维护性，一个方法，一个参数，强制了功能的单一性，很自然就做到了功能的内聚，降低耦合

# 防抖和节流
在前端开发中有一部分用户行为会频繁的触发事件的执行，对于dom操作，资源加载等耗费性能的处理，很可能导致界面卡顿，甚至浏览器的崩溃，函数节流（throttle）和函数防抖（debounce）就是为了解决类似的需求应运而生


# 关于闭包的补充
闭包是一种现象 本来局部变量在外层是访问不到的 但是通过return返回一个函数 函数内有一个内层的变量 使得这个局部变量就有了不被销毁的理由。在这里产生了一个闭包结构，局部变量的生命看起来被延续了。  
一个经典案例：
                function cs(){
                    var result = new Array();

                    for (var i=0; i < 10; i++){
                        result[i] = function(){  每次循环只会将这个函数赋给数组的每一项 但是函数内的语句并不会执行
                            return i;
                        };
                    }

                    return result;
                } 
            执行数组内的每一个时发现都是10  因为这个i仍然是cs内的 循环完之后i变成了10 这就是闭包 在外部可以拿到内层作用域的变量
            解决办法也很简单 

  function cs(){
                    var result = new Array();

                    for (var i=0; i < 10; i++){
                        (function(j){
                        result[j] = function(){   当然这个匿名函数也不会执行 但是i作为实参已经传入立即执行函数内 
                            return j;
                        }
                        })(i);
                    }

                    return result;
                } 
            //加一个立即执行函数  作用域就不同了 再执行时 他会找自己作用域的j值

闭包会导致原有作用域链不释放，造成内存泄漏

闭包的作用
实现公有变量
可以做缓存（存储结构）
可以实现封装，属性私有化
模块化开发，防止污染全局变量